<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# queue

[![Go Reference](https://pkg.go.dev/badge/github.com/fireflycons/concurrentqueue.svg)](https://pkg.go.dev/github.com/fireflycons/concurrentqueue) [![build](https://github.com/fireflycons/concurrentqueue/actions/workflows/build.yml/badge.svg)](https://github.com/fireflycons/concurrentqueue/actions/workflows/build.yml) [![Go Report Card](https://goreportcard.com/badge/github.com/fireflycons/concurrentqueue)](https://goreportcard.com/report/github.com/fireflycons/concurrentqueue)


Package queue implements a mutex\-free channel\-based generic queue. It is not designed for raw speed, but rather to be used as a data source for things like worker pools where reading input from a channel makes sense.

The queue is backed by a ring buffer with a default initial capacity of 256 elements that grows as needed. A constructor method is provided to set the initial capacity if desired.

Where locking is required, it is done at the ring buffer level using spinlocks to minimize contention.

## Features

* Dependency free
* Mutex free
* Concurrent
* Generic
* Channel based implementation
* Backed by a ringbuffer for reduced allocs
* Used by my [workerpool](https://pkg.go.dev/github.com/fireflycons/workerpool) implementation

## Example

```go
package main

import (
	"fmt"

	queue "github.com/fireflycons/concurrentqueue"
)

func main() {
	q := queue.New[int]()

	for i := range 10 {
		_ = q.Enqueue(i)
	}

	// Close the queue to signal no more elements will be added
	q.Close()

	// Dequeue is a channel, therefore it would block until elements are available
	// or the queue is closed and emptied.
	for v := range q.Dequeue() {
		fmt.Println(v)
	}
}
```